generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String          @id @default(cuid())
  name          String?
  email         String          @unique
  emailVerified DateTime?
  image         String?
  accounts      Account[]
  sessions      Session[]
  documents     Document[]
  // Optional for WebAuthn support
  Authenticator Authenticator[]
  rateLimit     RateLimit?
 
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
 
model Account {
  userId                   String
  type                     String
  provider                 String
  providerAccountId        String
  refresh_token            String?
  access_token             String?
  expires_at               Int?
  token_type               String?
  scope                    String?
  id_token                 String?
  session_state            String?
  refresh_token_expires_in Int?
 
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
 
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
 
  @@id([provider, providerAccountId])
}
 
model Session {
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
 
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
 
model VerificationToken {
  identifier String
  token      String
  expires    DateTime
 
  @@id([identifier, token])
}
 
// Optional for WebAuthn support
model Authenticator {
  credentialID         String  @unique
  userId               String
  providerAccountId    String
  credentialPublicKey  String
  counter              Int
  credentialDeviceType String
  credentialBackedUp   Boolean
  transports           String?
 
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
 
  @@id([userId, credentialID])
}

model Document {
  id          String    @id @default(cuid())
  userId      String
  name        String    @unique
  createdAt   DateTime  @default(now())
  preview     Preview?
  log         Log?
 
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade) // user to document is a one to many relationship. the user "owns" many documents
  @@unique([userId, name]) // unique document name per user
}

model Preview {
  id            String    @id @default(cuid())
  documentId    String    @unique // ensure 1-1 relationship
  presignedUrl  String?           // temp url to aws s3 image
  expiry        DateTime?         // when it expires
  
  document    Document    @relation(fields: [documentId], references: [id]) // preview to document relationship is one to one. documents own one or zero previews
}

enum Role {
  USER 
  AGENT
}

model Log {
  id            String    @id @default(cuid())
  documentId    String    @unique // ensure 1-1 relationship
  messages      Message[]

  document    Document    @relation(fields: [documentId], references: [id]) // log to document relationship is one to one. documents own one or zero logs
}

model Message {
  id            String    @id @default(cuid())
  logId         String
  text          String
  createdAt     DateTime  @default(now())
  role          Role

  log           Log       @relation(fields: [logId], references: [id]) // log to message relationship is one to many. a log can have many messages
}

// a rate limit record will be created for each day the user logs on and uses the site (uploads or prompts). once they hit the limit they will be refused service 
// until the date is one day old, where the current record will be deleted and replaced with a new one for that new active day. simplifies checking in the api, 
// I can just check if it exists, and what the counts are at and if it is still valid (not one day old or more). if they hit the limit refuse service else just
// update the count by either updating the existing valid unexpired record or creating a new one for the day
model RateLimit {
  id                String    @id @default(cuid())
  userId            String    @unique // ensure 1-1 relationship
  file_uploads      Int       @default(0)
  prompt_uploads    Int       @default(0)
  date              DateTime  @default(now())

  user              User      @relation(fields: [userId], references: [id]) // user to RateLimit is a one to one relationship. the user "owns" one or zero rate limits, rate limits must be tied to a user
}
